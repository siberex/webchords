{
  "_args": [
    [
      {
        "raw": "@webcomponents/shadycss@github:webcomponents/shadycss#v1.0.0-rc.2",
        "scope": "@webcomponents",
        "escapedName": "@webcomponents%2fshadycss",
        "name": "@webcomponents/shadycss",
        "rawSpec": "github:webcomponents/shadycss#v1.0.0-rc.2",
        "spec": "github:webcomponents/shadycss#v1.0.0-rc.2",
        "type": "hosted",
        "hosted": {
          "type": "github",
          "ssh": "git@github.com:webcomponents/shadycss.git#v1.0.0-rc.2",
          "sshUrl": "git+ssh://git@github.com/webcomponents/shadycss.git#v1.0.0-rc.2",
          "httpsUrl": "git+https://github.com/webcomponents/shadycss.git#v1.0.0-rc.2",
          "gitUrl": "git://github.com/webcomponents/shadycss.git#v1.0.0-rc.2",
          "shortcut": "github:webcomponents/shadycss#v1.0.0-rc.2",
          "directUrl": "https://raw.githubusercontent.com/webcomponents/shadycss/v1.0.0-rc.2/package.json"
        }
      },
      "/Users/sib/Documents/_petprojects/webcomponent-musical-notation/docs"
    ]
  ],
  "_from": "webcomponents/shadycss#v1.0.0-rc.2",
  "_id": "@webcomponents/shadycss@1.0.0-rc.2",
  "_inCache": true,
  "_location": "/@webcomponents/shadycss",
  "_phantomChildren": {},
  "_requested": {
    "raw": "@webcomponents/shadycss@github:webcomponents/shadycss#v1.0.0-rc.2",
    "scope": "@webcomponents",
    "escapedName": "@webcomponents%2fshadycss",
    "name": "@webcomponents/shadycss",
    "rawSpec": "github:webcomponents/shadycss#v1.0.0-rc.2",
    "spec": "github:webcomponents/shadycss#v1.0.0-rc.2",
    "type": "hosted",
    "hosted": {
      "type": "github",
      "ssh": "git@github.com:webcomponents/shadycss.git#v1.0.0-rc.2",
      "sshUrl": "git+ssh://git@github.com/webcomponents/shadycss.git#v1.0.0-rc.2",
      "httpsUrl": "git+https://github.com/webcomponents/shadycss.git#v1.0.0-rc.2",
      "gitUrl": "git://github.com/webcomponents/shadycss.git#v1.0.0-rc.2",
      "shortcut": "github:webcomponents/shadycss#v1.0.0-rc.2",
      "directUrl": "https://raw.githubusercontent.com/webcomponents/shadycss/v1.0.0-rc.2/package.json"
    }
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "git://github.com/webcomponents/shadycss.git#3c4fd2abb326f59a2df2c22001c0e30f4523c3d3",
  "_shasum": "709c24d65a208db27010d5748099d3bca6c1e340",
  "_shrinkwrap": null,
  "_spec": "@webcomponents/shadycss@github:webcomponents/shadycss#v1.0.0-rc.2",
  "_where": "/Users/sib/Documents/_petprojects/webcomponent-musical-notation/docs",
  "author": {
    "name": "The Polymer Authors"
  },
  "bugs": {
    "url": "https://github.com/webcomponents/shadycss/issues"
  },
  "dependencies": {},
  "description": "Styling helpers for ShadyDOM",
  "devDependencies": {
    "del": "^2.2.2",
    "eslint": "^3.4.0",
    "eslint-plugin-html": "^2.0.0",
    "google-closure-compiler": "^20170218.0.0",
    "gulp": "^3.8.8",
    "gulp-rename": "^1.2.2",
    "gulp-size": "^2.1.0",
    "gulp-sourcemaps": "^2.4.0",
    "rollup-stream": "^1.14.0",
    "run-sequence": "^1.2.2",
    "vinyl-buffer": "^1.0.0",
    "vinyl-source-stream": "^1.1.0",
    "web-component-tester": "^6.0.0-prerelease.4"
  },
  "directories": {
    "test": "tests"
  },
  "gitHead": "3c4fd2abb326f59a2df2c22001c0e30f4523c3d3",
  "homepage": "http://webcomponents.org",
  "license": "BSD-3-Clause",
  "main": "shadycss.min.js",
  "name": "@webcomponents/shadycss",
  "optionalDependencies": {},
  "readme": "# ShadyCSS\n\nShadyCSS provides a library to simulate ShadowDOM style encapsulation (ScopingShim), a shim for the proposed CSS mixin `@apply` styntax (ApplyShim), and a library to integrate document-level stylesheets with both of the former libraries (CustomStyleInterface).\n\n## Requirements\nShadyCSS requires support for the `<template>` element, ShadowDOM, MutationObserver, Promise, and Object.assign\n\n## Loading\n\nShadyCSS can be used by loading the ScopingShim, ApplyShim, CustomStyleInterface, or any combination of those.\n\nThe most-supported loading order is:\n1. ScopingShim\n1. ApplyShim\n1. CustomStyleInterface\n\nAll libraries will expose an object on `window` named `ShadyCSS` with the following interface:\n\n```js\nShadyCSS = {\n  prepareTemplate(templateElement, elementName, elementExtension){},\n  styleElement(element){},\n  styleSubtree(element, overrideProperties){},\n  styleDocument(overrideProperties){},\n  getComputedStyleValue(element, propertyName){\n    return // style value for property name on element\n  },\n  nativeCss: Boolean,\n  nativeShadow: Boolean\n}\n```\n\n## About ScopingShim\n\nScopingShim provides simulated ShadyDOM style encapsulation, and a shim for CSS Custom Properties.\n\nScopingShim works by rewriting style contents and transforming selectors to enforce scoping.\nAdditionally, if CSS Custom Properties is not detected, ScopingShim will replace CSS Custom Property usage with realized values.\n\n### Example:\nHere's an example of a custom element when Scoping Shim is not needed.\n\n```html\n<my-element>\n  <!-- shadow-root -->\n  <style>\n  :host {\n    display: block;\n  }\n  #container slot::slotted(*) {\n    color: gray;\n  }\n  #foo {\n    color: black;\n  }\n  </style>\n  <div id=\"foo\">Shadow</div>\n  <div id=\"container\">\n    <slot>\n      <!-- span distributed here -->\n    </slot>\n  </div>\n  <!-- /shadow-root -->\n  <span>Light</span>\n</my-element>\n```\n\nbecomes:\n\n```html\n<style scope=\"my-element\">\nmy-element {\n  display: block;\n}\n#container.my-element > * {\n  color: gray;\n}\n#foo.my-element {\n  color: black;\n}\n</style>\n<my-element>\n<div id=\"foo\">Shadow</div>\n<div id=\"container\">\n  <span>Light</span>\n</div>\n</my-element>\n```\n\n## About ApplyShim\n\nApplyShim provides a shim for the `@apply` syntax proposed at https://tabatkins.github.io/specs/css-apply-rule/, which expands the definition CSS Custom Properties to include objects that can be applied as a block.\n\nThis is done by transforming the block definition into a set of CSS Custom Properties, and replacing uses of `@apply` with consumption of those custom properties.\n\n### Example:\n\nHere we define a block called `--mixin` at the document level, and apply that block to `my-element` somewhere in the page.\n\n```css\nhtml {\n  --mixin: {\n    border: 2px solid black;\n    background-color: green;\n  }\n}\n\nmy-element {\n  border: 1px dotted orange;\n  @apply --mixin;\n}\n```\n\nbecomes:\n\n```css\nhtml {\n  --mixin_-_border: 2px solid black;\n  --mixin_-_background-color: green;\n}\n\nmy-element {\n  border: var(--mixin_-_border, 1px dotted orange);\n  background-color: var(--mixin_-_background-color);\n}\n```\n\n## About CustomStyleInterface\n\nCustomStyleInterface provides API to process `<style>` elements that are not inside of\nShadowRoots, and simulate upper-boundary style scoping for ShadyDOM.\n\nTo add document-level styles to ShadyCSS, one can call `CustomStyleInterface.addCustomStyle(styleElement)` or `CustomStyleInterface.addCustomStyle({getStyle: () => styleElement})`\n\nAn example usage of the document-level styling api can be found in `examples/document-style-lib.js`, and another example that uses a custom element wrapper can be found in `examples/custom-style-element.js`\n\n### Example:\n\n```html\n<style class=\"document-style\">\nhtml {\n  --content-color: brown;\n}\n</style>\n<my-element>This text will be brown!</my-element>\n<script>\nCustomStyleInterface.addCustomStyle(document.querySelector('style.document-style'));\n</script>\n```\n\nAnother example with a wrapper `<custom-style>` element\n\n```html\n<custom-style>\n  <style>\n  html {\n    --content-color: brown;\n  }\n  </style>\n</custom-style>\n<script>\nclass CustomStyle extends HTMLElement {\n  constructor() {\n    CustomStyleInterface.addCustomStyle(this);\n  }\n  getStyle() {\n    return this.querySelector('style');\n  }\n}\n</script>\n<my-element>This this text will be brown!</my-element>\n```\n\nAnother example with a function that produces style elements\n\n```html\n<my-element>This this text will be brown!</my-element>\n<script>\nCustomStyleInterface.addCustomStyle({\n  getStyle() {\n    const s = document.createElement('style');\n    s.textContent = 'html{ --content-color: brown }';\n    return s;\n  }\n});\n</script>\n```\n\n## Usage\n\nTo use ShadyCSS:\n\n1. First, call `ShadyCSS.prepareTemplate(template, name)` on a\n`<template>` element that will be imported into a `shadowRoot`.\n\n2. When the element instance is connected, call `ShadyCSS.styleElement(element)`\n\n3. Create and stamp the element's shadowRoot\n\n4. Whenever dynamic updates are required, call `ShadyCSS.styleSubtree(element)`.\n\n5. If a styling change is made that may affect the whole document, call\n`ShadyCSS.styleDocument()`.\n\nThe following example uses ShadyCSS and ShadyDOM to define a custom element.\n\n```html\n<template id=\"myElementTemplate\">\n  <style>\n    :host {\n      display: block;\n      padding: 8px;\n    }\n\n    #content {\n      background-color: var(--content-color);\n    }\n\n    .slot-container ::slotted(*) {\n      border: 1px solid steelblue;\n      margin: 4px;\n    }\n  </style>\n  <div id=\"content\">Content</div>\n  <div class=\"slot-container\">\n    <slot></slot>\n  </div>\n</template>\n<script>\n  ShadyCSS.prepareTemplate(myElementTemplate, 'my-element');\n  class MyElement extends HTMLElement {\n    connectedCallback() {\n      ShadyCSS.styleElement(this);\n      if (!this.shadowRoot) {\n        this.attachShadow({mode: 'open'});\n        this.shadowRoot.appendChild(\n          document.importNode(myElementTemplate.content, true));\n      }\n    }\n  }\n\n  customElements.define('my-element', MyElement);\n</script>\n```\n\n## Type Extension elements\n\nShadyCSS can also be used with type extension elements by supplying the base\nelement name to `prepareTemplate` as a third argument.\n\n### Example\n\n```html\n<template id=\"myElementTemplate\">\n  <style>\n    :host {\n      display: block;\n      padding: 8px;\n    }\n\n    #content {\n      background-color: var(--content-color);\n    }\n\n    .slot-container ::slotted(*) {\n      border: 1px solid steelblue;\n      margin: 4px;\n    }\n  </style>\n  <div id=\"content\">Content</div>\n  <div class=\"slot-container\">\n    <slot></slot>\n  </div>\n</template>\n<script>\n  ShadyCSS.prepareTemplate(myElementTemplate, 'my-element', 'div');\n  class MyElement extends HTMLDivElement {\n    connectedCallback() {\n      ShadyCSS.styleElement(this);\n      if (!this.shadowRoot) {\n        this.attachShadow({mode: 'open'});\n        this.shadowRoot.appendChild(\n          document.importNode(myElementTemplate.content, true));\n      }\n    }\n  }\n\n  customElements.define('my-element', MyElement, {extends: 'div'});\n</script>\n```\n\n## Imperative values for Custom properties\n\nTo set the value of a CSS Custom Property imperatively, `ShadyCSS.styleSubtree`\nand `ShadyCSS.styleDocument` support an additional argument of an object mapping\nvariable name to value.\n\nWhen using ApplyShim, defining new mixins or new values for current mixins imperatively is not\nsupported.\n\n### Example\n```html\n<my-element id=\"a\">Text</my-element>\n<my-element>Text</my-element>\n<script>\nlet el = document.querySelector('my-element#a');\n// Set the color of all my-element instances to 'green'\nShadyCSS.styleDocument({'--content-color' : 'green'});\n// Set the color my-element#a's text to 'red'\nShadyCSS.styleSubtree(el, {'--content-color' : 'red'});\n</script>\n```\n\n## Limitations\n\n### Selector scoping\n\nYou must have a selector to the left of the `::slotted`\npseudo-element.\n\n### Custom properties and `@apply`\n\nDynamic changes are not automatically applied. If elements change such that they\nconditionally match selectors they did not previously, `ShadyCSS.styleDocument()`\nmust be called.\n\nFor a given element's shadowRoot, only 1 value is allowed per custom properties.\nProperties cannot change from parent to child as they can under native custom\nproperties; they can only change when a shadowRoot boundary is crossed.\n\nTo receive a custom property, an element must directly match a selector that\ndefines the property in its host's stylesheet.\n\n### `<custom-style>` Flash of unstyled content\n\nIf `ShadyCss.applyStyle` is never called, `<custom-style>` elements will process\nafter HTML Imports have loaded, after the document loads, or after the next paint.\nThis means that there may be a flash of unstyled content on the first load.\n\n### Mixins do not cascade throught `<slot>`\n\nCrawling the DOM and updating styles is very expensive, and we found that trying to\nupdate mixins through `<slot>` insertion points to be too expensive to justify for both\npolyfilled CSS Mixins and polyfilled CSS Custom Properties.",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/webcomponents/shadycss.git"
  },
  "scripts": {
    "build": "gulp",
    "lint": "eslint src test entrypoints",
    "test": "npm run lint && gulp test-modules && wct"
  },
  "version": "1.0.0-rc.2"
}
